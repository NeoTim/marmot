// Code generated by protoc-gen-go.
// source: marmot.proto
// DO NOT EDIT!

/*
Package marmot is a generated protocol buffer package.

It is generated from these files:
	marmot.proto

It has these top-level messages:
	State
	Timing
	HashedData
	Labor
	Task
	Sequence
	Job
	SubmitReq
	SubmitResp
	MonitorReq
	MonitorResp
	StartReq
	StartResp
	PauseReq
	PauseResp
	ResumeReq
	ResumeResp
	StopReq
	StopResp
	LaborFilter
	LaborSearchReq
	FetchLaborReq
*/
package marmot

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// States represents the various states a container object can be in.
type States int32

const (
	States_UNKNOWN States = 0
	// NotStarted indicates that the object hasn't started execution.
	States_NOT_STARTED States = 1
	// AdminNotStarted indicates the Labor object was sent to the server, but
	// was not intended to run until started by an RPC or human.
	States_ADMIN_NOT_STARTED States = 2
	// Running indicates the object is currently executing.
	States_RUNNING States = 3
	// Pausing indicates the object is intending to pause execution.
	States_PAUSING States = 4
	// Paused indicates the object has paused execution.
	States_PAUSED States = 5
	// AdminPaused indicates that a human has paused execution.
	States_ADMIN_PAUSED States = 6
	// CrisisPaused indicates that the crisis service for emergency control has
	// paused execution.
	States_CRISIS_PAUSED States = 7
	// Completed indicates the object has completed execution successfully.
	States_COMPLETED States = 8
	// Failed indicates the object failed its execution.
	States_FAILED States = 9
	// Stopping indicates the object is attempting to stop.
	States_STOPPING States = 10
	// Stopped indicates the object's execution was stopped.
	States_STOPPED States = 11
)

var States_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "NOT_STARTED",
	2:  "ADMIN_NOT_STARTED",
	3:  "RUNNING",
	4:  "PAUSING",
	5:  "PAUSED",
	6:  "ADMIN_PAUSED",
	7:  "CRISIS_PAUSED",
	8:  "COMPLETED",
	9:  "FAILED",
	10: "STOPPING",
	11: "STOPPED",
}
var States_value = map[string]int32{
	"UNKNOWN":           0,
	"NOT_STARTED":       1,
	"ADMIN_NOT_STARTED": 2,
	"RUNNING":           3,
	"PAUSING":           4,
	"PAUSED":            5,
	"ADMIN_PAUSED":      6,
	"CRISIS_PAUSED":     7,
	"COMPLETED":         8,
	"FAILED":            9,
	"STOPPING":          10,
	"STOPPED":           11,
}

func (x States) String() string {
	return proto.EnumName(States_name, int32(x))
}
func (States) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Reasons are reasons why a container failed.
type Reasons int32

const (
	// Indicates that no failure occurred.
	Reasons_NO_FAILURE Reasons = 0
	// Indicates that a pre-check failed.
	Reasons_PRE_CHECK_FAILURE Reasons = 1
	// Indicates that a post-check failed.
	Reasons_CONT_CHECK_FAILURE Reasons = 2
	// Inidcates that a max failure occurred.
	Reasons_MAX_FAILURES Reasons = 3
)

var Reasons_name = map[int32]string{
	0: "NO_FAILURE",
	1: "PRE_CHECK_FAILURE",
	2: "CONT_CHECK_FAILURE",
	3: "MAX_FAILURES",
}
var Reasons_value = map[string]int32{
	"NO_FAILURE":         0,
	"PRE_CHECK_FAILURE":  1,
	"CONT_CHECK_FAILURE": 2,
	"MAX_FAILURES":       3,
}

func (x Reasons) String() string {
	return proto.EnumName(Reasons_name, int32(x))
}
func (Reasons) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// State represents the state of a container.
type State struct {
	// State is the current state of a container.
	State States `protobuf:"varint,1,opt,name=state,enum=marmot.States" json:"state,omitempty"`
	// Reason is the reason for a failure.
	Reason Reasons `protobuf:"varint,2,opt,name=reason,enum=marmot.Reasons" json:"reason,omitempty"`
}

func (m *State) Reset()                    { *m = State{} }
func (m *State) String() string            { return proto.CompactTextString(m) }
func (*State) ProtoMessage()               {}
func (*State) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Timing describes when objects start and stop.
type Timing struct {
	// Started is when the object started execution.
	Started int64 `protobuf:"varint,1,opt,name=Started" json:"Started,omitempty"`
	// Ended is when the object ended execution.
	Ended int64 `protobuf:"varint,2,opt,name=Ended" json:"Ended,omitempty"`
	// Submitted is when the object was added to the system.
	// Only valid for Labor objects.
	Submitted int64 `protobuf:"varint,3,opt,name=Submitted" json:"Submitted,omitempty"`
}

func (m *Timing) Reset()                    { *m = Timing{} }
func (m *Timing) String() string            { return proto.CompactTextString(m) }
func (*Timing) ProtoMessage()               {}
func (*Timing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// HashedData holds
type HashedData struct {
}

func (m *HashedData) Reset()                    { *m = HashedData{} }
func (m *HashedData) String() string            { return proto.CompactTextString(m) }
func (*HashedData) ProtoMessage()               {}
func (*HashedData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Labor is the top level container representing all the work to be done.
type Labor struct {
	// Private holds fields that are used by the client/server, not users
	// directly.
	Private *Labor_Private `protobuf:"bytes,1,opt,name=private" json:"private,omitempty"`
	// A UUIDv4 identifier.  Cannot be set by the client.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// A UUIDv4 identifier.  This must be set by the client.  Prevents multiple
	// duplicate submissions in a multi-master environment.
	ClientId string `protobuf:"bytes,3,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	// Name is a descriptive name for the Labor.
	Name string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Desc is a longer description of what the Labor is trying to accomplish.
	Desc string `protobuf:"bytes,5,opt,name=desc" json:"desc,omitempty"`
	// Tags provides a list of labels attached to the Labor.
	Tags []string `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
	// Timing includes information on various timing of operations.
	Timing *Timing `protobuf:"bytes,7,opt,name=timing" json:"timing,omitempty"`
	// State holds the current state of the Labor.  This cannot be set by the
	// sender.
	State *State `protobuf:"bytes,8,opt,name=state" json:"state,omitempty"`
	// Tasks are sub-containers of a Labor.
	Tasks []*Task `protobuf:"bytes,9,rep,name=tasks" json:"tasks,omitempty"`
}

func (m *Labor) Reset()                    { *m = Labor{} }
func (m *Labor) String() string            { return proto.CompactTextString(m) }
func (*Labor) ProtoMessage()               {}
func (*Labor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Labor) GetPrivate() *Labor_Private {
	if m != nil {
		return m.Private
	}
	return nil
}

func (m *Labor) GetTiming() *Timing {
	if m != nil {
		return m.Timing
	}
	return nil
}

func (m *Labor) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Labor) GetTasks() []*Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type Labor_Private struct {
}

func (m *Labor_Private) Reset()                    { *m = Labor_Private{} }
func (m *Labor_Private) String() string            { return proto.CompactTextString(m) }
func (*Labor_Private) ProtoMessage()               {}
func (*Labor_Private) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

// Tasks represent a set of work that will be done as a group at a certain
// concurrency level with a certain failure tolerance.  Tasks can be used
// divide sections of work from each other, such as canarying a change and the
// main block of changes.  Or it could be used to divide up tasks with breaks
// of 30 minutes between each set, etc....
type Task struct {
	// Private holds fields that are used by the client/server, not users
	// directly.
	Private *Task_Private `protobuf:"bytes,1,opt,name=private" json:"private,omitempty"`
	// A UUIDv4 identifier.  Cannot be set by the client.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Name is a descriptive name for a Task.
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Desc is a longer description of what the Task is trying to accomplish.
	Desc string `protobuf:"bytes,4,opt,name=desc" json:"desc,omitempty"`
	// Timing includes information on various timing of operations.
	Timing *Timing `protobuf:"bytes,5,opt,name=timing" json:"timing,omitempty"`
	// State holds the current state of the Task.  This cannot be set by the
	// sender.
	State *State `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
	// The amount of failures, if exceeded, will cause
	// the Task to Fail.
	ToleratedFailures int64 `protobuf:"varint,7,opt,name=tolerated_failures,json=toleratedFailures" json:"tolerated_failures,omitempty"`
	// The amount of Sequences to execute in Tandem.
	Concurrency int64 `protobuf:"varint,8,opt,name=concurrency" json:"concurrency,omitempty"`
	//  How long to wait between the contChecks completing
	// and the next time to run the checks, in seconds.
	ContCheckInterval int64 `protobuf:"varint,9,opt,name=cont_check_interval,json=contCheckInterval" json:"cont_check_interval,omitempty"`
	// Indicates to pass the amount of failures that occurred in
	// this Task onto the next Task.  The next Task will start with that number
	// of failures instead of 0.
	PassFailures bool `protobuf:"varint,10,opt,name=pass_failures,json=passFailures" json:"pass_failures,omitempty"`
	// Jobs to run that act as pre-checks.  These Jobs run concurrently before
	// the sequences run and if any fail, the Task automatically fails.
	PreChecks []*Job `protobuf:"bytes,11,rep,name=pre_checks,json=preChecks" json:"pre_checks,omitempty"`
	// Jobs to run that act as both pre-checks and are run at cont_check_intervals
	// for the life of the Task.  If any Jobs fail, the Task fails.
	ContChecks []*Job `protobuf:"bytes,12,rep,name=cont_checks,json=contChecks" json:"cont_checks,omitempty"`
	// Sequences to run at the concurrency level set.
	Sequences []*Sequence `protobuf:"bytes,13,rep,name=sequences" json:"sequences,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Task) GetPrivate() *Task_Private {
	if m != nil {
		return m.Private
	}
	return nil
}

func (m *Task) GetTiming() *Timing {
	if m != nil {
		return m.Timing
	}
	return nil
}

func (m *Task) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Task) GetPreChecks() []*Job {
	if m != nil {
		return m.PreChecks
	}
	return nil
}

func (m *Task) GetContChecks() []*Job {
	if m != nil {
		return m.ContChecks
	}
	return nil
}

func (m *Task) GetSequences() []*Sequence {
	if m != nil {
		return m.Sequences
	}
	return nil
}

type Task_Private struct {
}

func (m *Task_Private) Reset()                    { *m = Task_Private{} }
func (m *Task_Private) String() string            { return proto.CompactTextString(m) }
func (*Task_Private) ProtoMessage()               {}
func (*Task_Private) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

// A series of Jobs, usually targeted at a particular entity (device, cluster,...)
// A Sequence executes sequentially in the order the Jobs were added until
// either a Job fails or all Jobs complete.
type Sequence struct {
	// Private holds fields that are used by the client/server, not users
	// directly.
	Private *Sequence_Private `protobuf:"bytes,1,opt,name=private" json:"private,omitempty"`
	// A UUIDv4 identifier.  Cannot be set by the client.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// target is the name of what this sequence targets. This could be a device,
	// a service, a directory... whatever makes sense for whatever is being done.
	Target string `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	Desc   string `protobuf:"bytes,4,opt,name=desc" json:"desc,omitempty"`
	// Timing includes information on various timing of operations.
	Timing *Timing `protobuf:"bytes,5,opt,name=timing" json:"timing,omitempty"`
	// State holds the current state of the Sequence.  This cannot be set by the
	// sender.
	State *State `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
	// Jobs is a set of Jobs to execute.
	Jobs []*Job `protobuf:"bytes,10,rep,name=jobs" json:"jobs,omitempty"`
}

func (m *Sequence) Reset()                    { *m = Sequence{} }
func (m *Sequence) String() string            { return proto.CompactTextString(m) }
func (*Sequence) ProtoMessage()               {}
func (*Sequence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Sequence) GetPrivate() *Sequence_Private {
	if m != nil {
		return m.Private
	}
	return nil
}

func (m *Sequence) GetTiming() *Timing {
	if m != nil {
		return m.Timing
	}
	return nil
}

func (m *Sequence) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Sequence) GetJobs() []*Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

type Sequence_Private struct {
}

func (m *Sequence_Private) Reset()                    { *m = Sequence_Private{} }
func (m *Sequence_Private) String() string            { return proto.CompactTextString(m) }
func (*Sequence_Private) ProtoMessage()               {}
func (*Sequence_Private) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

// Job represents a plugin that will be executed.
type Job struct {
	// Private holds fields that are used by the client/server, not users
	// directly.
	Private *Job_Private `protobuf:"bytes,1,opt,name=private" json:"private,omitempty"`
	// A UUIDv4 identifier.  Cannot be set by the client.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// The path to the plugin.
	Plugin string `protobuf:"bytes,3,opt,name=plugin" json:"plugin,omitempty"`
	// Description of what your attempting to do.
	Desc string `protobuf:"bytes,4,opt,name=desc" json:"desc,omitempty"`
	// Timeout is how long, in seconds, to wait for the Job to complete.  If not
	// set this defaults to 5 minutes.
	Timeout int64 `protobuf:"varint,5,opt,name=timeout" json:"timeout,omitempty"`
	// Timing includes information on various timing of operations.
	Timing *Timing `protobuf:"bytes,6,opt,name=timing" json:"timing,omitempty"`
	// State holds the current state of the Job.  This cannot be set by the
	// sender.
	State *State `protobuf:"bytes,7,opt,name=state" json:"state,omitempty"`
	// The arguments to send to the plugin.  Args are protocol buffer
	// version 3 in JSON format.
	Args string `protobuf:"bytes,8,opt,name=args" json:"args,omitempty"`
	// The result from the plugin.  Output is a protocol buffer version 3 in
	// JSON format.
	Output string `protobuf:"bytes,9,opt,name=Output" json:"Output,omitempty"`
	// This is how many times to retry if the initial attempt fails.
	Retries int64 `protobuf:"varint,10,opt,name=retries" json:"retries,omitempty"`
	// This is how long to wait, in seconds, before doing a retry.
	RetryDelay int64 `protobuf:"varint,11,opt,name=retry_delay,json=retryDelay" json:"retry_delay,omitempty"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Job) GetPrivate() *Job_Private {
	if m != nil {
		return m.Private
	}
	return nil
}

func (m *Job) GetTiming() *Timing {
	if m != nil {
		return m.Timing
	}
	return nil
}

func (m *Job) GetState() *State {
	if m != nil {
		return m.State
	}
	return nil
}

type Job_Private struct {
	// args_hash holds the hash to lookup the data for args in Labor.hashed_data.
	// This is used internally, where users can normally just look at .args.
	ArgsHash string `protobuf:"bytes,9,opt,name=args_hash,json=argsHash" json:"args_hash,omitempty"`
	// output_hash holds the hash to lookup the data for output in
	// Labor.hashed_data.  This is used internally, where users can normally
	// just look at .output.
	OutputHash string `protobuf:"bytes,10,opt,name=output_hash,json=outputHash" json:"output_hash,omitempty"`
}

func (m *Job_Private) Reset()                    { *m = Job_Private{} }
func (m *Job_Private) String() string            { return proto.CompactTextString(m) }
func (*Job_Private) ProtoMessage()               {}
func (*Job_Private) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

// A request to submit a Labor for processing.
type SubmitReq struct {
	// The Labor to process.
	Labor *Labor `protobuf:"bytes,1,opt,name=labor" json:"labor,omitempty"`
	// If set, will begin execution immediately.
	StartOnSubmit bool `protobuf:"varint,2,opt,name=StartOnSubmit" json:"StartOnSubmit,omitempty"`
}

func (m *SubmitReq) Reset()                    { *m = SubmitReq{} }
func (m *SubmitReq) String() string            { return proto.CompactTextString(m) }
func (*SubmitReq) ProtoMessage()               {}
func (*SubmitReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SubmitReq) GetLabor() *Labor {
	if m != nil {
		return m.Labor
	}
	return nil
}

// The response to a Submit().
type SubmitResp struct {
	// The UUIDv4 representing the Labor.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *SubmitResp) Reset()                    { *m = SubmitResp{} }
func (m *SubmitResp) String() string            { return proto.CompactTextString(m) }
func (*SubmitResp) ProtoMessage()               {}
func (*SubmitResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// A request to monitor a Labor until it completes.
type MonitorReq struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *MonitorReq) Reset()                    { *m = MonitorReq{} }
func (m *MonitorReq) String() string            { return proto.CompactTextString(m) }
func (*MonitorReq) ProtoMessage()               {}
func (*MonitorReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// A streaming response containing the Labor with only state data.
type MonitorResp struct {
	// The Labor with only the state data (no Args or Output for Jobs).
	Labor *Labor `protobuf:"bytes,2,opt,name=labor" json:"labor,omitempty"`
}

func (m *MonitorResp) Reset()                    { *m = MonitorResp{} }
func (m *MonitorResp) String() string            { return proto.CompactTextString(m) }
func (*MonitorResp) ProtoMessage()               {}
func (*MonitorResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MonitorResp) GetLabor() *Labor {
	if m != nil {
		return m.Labor
	}
	return nil
}

// Used to start a Labor that was submitted without StartOnSubmit set.
type StartReq struct {
	// The ID of the Labor.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *StartReq) Reset()                    { *m = StartReq{} }
func (m *StartReq) String() string            { return proto.CompactTextString(m) }
func (*StartReq) ProtoMessage()               {}
func (*StartReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

// The response to the request for Start().
type StartResp struct {
}

func (m *StartResp) Reset()                    { *m = StartResp{} }
func (m *StartResp) String() string            { return proto.CompactTextString(m) }
func (*StartResp) ProtoMessage()               {}
func (*StartResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

// Request that a Labor is paused.
type PauseReq struct {
	// The ID of the Labor to pause.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *PauseReq) Reset()                    { *m = PauseReq{} }
func (m *PauseReq) String() string            { return proto.CompactTextString(m) }
func (*PauseReq) ProtoMessage()               {}
func (*PauseReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

// The response to the request for Pause().
type PauseResp struct {
}

func (m *PauseResp) Reset()                    { *m = PauseResp{} }
func (m *PauseResp) String() string            { return proto.CompactTextString(m) }
func (*PauseResp) ProtoMessage()               {}
func (*PauseResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

// Request to unpause a Labor.
type ResumeReq struct {
	// The ID of the Labor to unpause.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *ResumeReq) Reset()                    { *m = ResumeReq{} }
func (m *ResumeReq) String() string            { return proto.CompactTextString(m) }
func (*ResumeReq) ProtoMessage()               {}
func (*ResumeReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

// The response to the request for Resume().
type ResumeResp struct {
}

func (m *ResumeResp) Reset()                    { *m = ResumeResp{} }
func (m *ResumeResp) String() string            { return proto.CompactTextString(m) }
func (*ResumeResp) ProtoMessage()               {}
func (*ResumeResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

// Request to stop a Labor.
type StopReq struct {
	// The ID of the Labor to stop.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *StopReq) Reset()                    { *m = StopReq{} }
func (m *StopReq) String() string            { return proto.CompactTextString(m) }
func (*StopReq) ProtoMessage()               {}
func (*StopReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

// The response to the request for Stop().
type StopResp struct {
}

func (m *StopResp) Reset()                    { *m = StopResp{} }
func (m *StopResp) String() string            { return proto.CompactTextString(m) }
func (*StopResp) ProtoMessage()               {}
func (*StopResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

// LaborFilter is a search filter used for searching for Labors.
type LaborFilter struct {
	// Statees returns objects that are currently at one the "states".
	// If empty, all states are included.
	States []States `protobuf:"varint,1,rep,packed,name=states,enum=marmot.States" json:"states,omitempty"`
	// Locates Labors starting with the string.
	NamePrefix string `protobuf:"bytes,2,opt,name=name_prefix,json=namePrefix" json:"name_prefix,omitempty"`
	// name_suffix locates Labors ending with the string.
	NameSuffix string `protobuf:"bytes,3,opt,name=name_suffix,json=nameSuffix" json:"name_suffix,omitempty"`
	// Matches any Labor that has any tag listed.
	Tags []string `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
	// Includes only Labors that were submitted at or after submit_begin.
	// This is recorded in unix epoch seconds.
	SubmitBegin int64 `protobuf:"varint,5,opt,name=submit_begin,json=submitBegin" json:"submit_begin,omitempty"`
	// Only include an object which was submitted before submit_end.
	// This is recorded in unix epoch seconds.
	SubmitEnd int64 `protobuf:"varint,6,opt,name=submit_end,json=submitEnd" json:"submit_end,omitempty"`
}

func (m *LaborFilter) Reset()                    { *m = LaborFilter{} }
func (m *LaborFilter) String() string            { return proto.CompactTextString(m) }
func (*LaborFilter) ProtoMessage()               {}
func (*LaborFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

// A request for searching out Labors meeting certain conditions.
type LaborSearchReq struct {
	// A filter for locating Labors.
	Filter *LaborFilter `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
}

func (m *LaborSearchReq) Reset()                    { *m = LaborSearchReq{} }
func (m *LaborSearchReq) String() string            { return proto.CompactTextString(m) }
func (*LaborSearchReq) ProtoMessage()               {}
func (*LaborSearchReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *LaborSearchReq) GetFilter() *LaborFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// FetchLaborReq is used to retrieve a single Labor from the service.
type FetchLaborReq struct {
	// The id of the Labor.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Indicates if the data for the Labor should be included.
	Full bool `protobuf:"varint,2,opt,name=full" json:"full,omitempty"`
}

func (m *FetchLaborReq) Reset()                    { *m = FetchLaborReq{} }
func (m *FetchLaborReq) String() string            { return proto.CompactTextString(m) }
func (*FetchLaborReq) ProtoMessage()               {}
func (*FetchLaborReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func init() {
	proto.RegisterType((*State)(nil), "marmot.State")
	proto.RegisterType((*Timing)(nil), "marmot.Timing")
	proto.RegisterType((*HashedData)(nil), "marmot.HashedData")
	proto.RegisterType((*Labor)(nil), "marmot.Labor")
	proto.RegisterType((*Labor_Private)(nil), "marmot.Labor.Private")
	proto.RegisterType((*Task)(nil), "marmot.Task")
	proto.RegisterType((*Task_Private)(nil), "marmot.Task.Private")
	proto.RegisterType((*Sequence)(nil), "marmot.Sequence")
	proto.RegisterType((*Sequence_Private)(nil), "marmot.Sequence.Private")
	proto.RegisterType((*Job)(nil), "marmot.Job")
	proto.RegisterType((*Job_Private)(nil), "marmot.Job.Private")
	proto.RegisterType((*SubmitReq)(nil), "marmot.SubmitReq")
	proto.RegisterType((*SubmitResp)(nil), "marmot.SubmitResp")
	proto.RegisterType((*MonitorReq)(nil), "marmot.MonitorReq")
	proto.RegisterType((*MonitorResp)(nil), "marmot.MonitorResp")
	proto.RegisterType((*StartReq)(nil), "marmot.StartReq")
	proto.RegisterType((*StartResp)(nil), "marmot.StartResp")
	proto.RegisterType((*PauseReq)(nil), "marmot.PauseReq")
	proto.RegisterType((*PauseResp)(nil), "marmot.PauseResp")
	proto.RegisterType((*ResumeReq)(nil), "marmot.ResumeReq")
	proto.RegisterType((*ResumeResp)(nil), "marmot.ResumeResp")
	proto.RegisterType((*StopReq)(nil), "marmot.StopReq")
	proto.RegisterType((*StopResp)(nil), "marmot.StopResp")
	proto.RegisterType((*LaborFilter)(nil), "marmot.LaborFilter")
	proto.RegisterType((*LaborSearchReq)(nil), "marmot.LaborSearchReq")
	proto.RegisterType((*FetchLaborReq)(nil), "marmot.FetchLaborReq")
	proto.RegisterEnum("marmot.States", States_name, States_value)
	proto.RegisterEnum("marmot.Reasons", Reasons_name, Reasons_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for MarmotService service

type MarmotServiceClient interface {
	Submit(ctx context.Context, in *SubmitReq, opts ...grpc.CallOption) (*SubmitResp, error)
	Monitor(ctx context.Context, in *MonitorReq, opts ...grpc.CallOption) (MarmotService_MonitorClient, error)
	Start(ctx context.Context, in *StartReq, opts ...grpc.CallOption) (*StartResp, error)
	Pause(ctx context.Context, in *PauseReq, opts ...grpc.CallOption) (*PauseResp, error)
	Resume(ctx context.Context, in *ResumeReq, opts ...grpc.CallOption) (*ResumeResp, error)
	Stop(ctx context.Context, in *StopReq, opts ...grpc.CallOption) (*StopResp, error)
	SearchLabor(ctx context.Context, in *LaborSearchReq, opts ...grpc.CallOption) (MarmotService_SearchLaborClient, error)
	FetchLabor(ctx context.Context, in *FetchLaborReq, opts ...grpc.CallOption) (*Labor, error)
}

type marmotServiceClient struct {
	cc *grpc.ClientConn
}

func NewMarmotServiceClient(cc *grpc.ClientConn) MarmotServiceClient {
	return &marmotServiceClient{cc}
}

func (c *marmotServiceClient) Submit(ctx context.Context, in *SubmitReq, opts ...grpc.CallOption) (*SubmitResp, error) {
	out := new(SubmitResp)
	err := grpc.Invoke(ctx, "/marmot.MarmotService/Submit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marmotServiceClient) Monitor(ctx context.Context, in *MonitorReq, opts ...grpc.CallOption) (MarmotService_MonitorClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MarmotService_serviceDesc.Streams[0], c.cc, "/marmot.MarmotService/Monitor", opts...)
	if err != nil {
		return nil, err
	}
	x := &marmotServiceMonitorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MarmotService_MonitorClient interface {
	Recv() (*MonitorResp, error)
	grpc.ClientStream
}

type marmotServiceMonitorClient struct {
	grpc.ClientStream
}

func (x *marmotServiceMonitorClient) Recv() (*MonitorResp, error) {
	m := new(MonitorResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *marmotServiceClient) Start(ctx context.Context, in *StartReq, opts ...grpc.CallOption) (*StartResp, error) {
	out := new(StartResp)
	err := grpc.Invoke(ctx, "/marmot.MarmotService/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marmotServiceClient) Pause(ctx context.Context, in *PauseReq, opts ...grpc.CallOption) (*PauseResp, error) {
	out := new(PauseResp)
	err := grpc.Invoke(ctx, "/marmot.MarmotService/Pause", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marmotServiceClient) Resume(ctx context.Context, in *ResumeReq, opts ...grpc.CallOption) (*ResumeResp, error) {
	out := new(ResumeResp)
	err := grpc.Invoke(ctx, "/marmot.MarmotService/Resume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marmotServiceClient) Stop(ctx context.Context, in *StopReq, opts ...grpc.CallOption) (*StopResp, error) {
	out := new(StopResp)
	err := grpc.Invoke(ctx, "/marmot.MarmotService/Stop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marmotServiceClient) SearchLabor(ctx context.Context, in *LaborSearchReq, opts ...grpc.CallOption) (MarmotService_SearchLaborClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MarmotService_serviceDesc.Streams[1], c.cc, "/marmot.MarmotService/SearchLabor", opts...)
	if err != nil {
		return nil, err
	}
	x := &marmotServiceSearchLaborClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MarmotService_SearchLaborClient interface {
	Recv() (*Labor, error)
	grpc.ClientStream
}

type marmotServiceSearchLaborClient struct {
	grpc.ClientStream
}

func (x *marmotServiceSearchLaborClient) Recv() (*Labor, error) {
	m := new(Labor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *marmotServiceClient) FetchLabor(ctx context.Context, in *FetchLaborReq, opts ...grpc.CallOption) (*Labor, error) {
	out := new(Labor)
	err := grpc.Invoke(ctx, "/marmot.MarmotService/FetchLabor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MarmotService service

type MarmotServiceServer interface {
	Submit(context.Context, *SubmitReq) (*SubmitResp, error)
	Monitor(*MonitorReq, MarmotService_MonitorServer) error
	Start(context.Context, *StartReq) (*StartResp, error)
	Pause(context.Context, *PauseReq) (*PauseResp, error)
	Resume(context.Context, *ResumeReq) (*ResumeResp, error)
	Stop(context.Context, *StopReq) (*StopResp, error)
	SearchLabor(*LaborSearchReq, MarmotService_SearchLaborServer) error
	FetchLabor(context.Context, *FetchLaborReq) (*Labor, error)
}

func RegisterMarmotServiceServer(s *grpc.Server, srv MarmotServiceServer) {
	s.RegisterService(&_MarmotService_serviceDesc, srv)
}

func _MarmotService_Submit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarmotServiceServer).Submit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marmot.MarmotService/Submit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarmotServiceServer).Submit(ctx, req.(*SubmitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarmotService_Monitor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MarmotServiceServer).Monitor(m, &marmotServiceMonitorServer{stream})
}

type MarmotService_MonitorServer interface {
	Send(*MonitorResp) error
	grpc.ServerStream
}

type marmotServiceMonitorServer struct {
	grpc.ServerStream
}

func (x *marmotServiceMonitorServer) Send(m *MonitorResp) error {
	return x.ServerStream.SendMsg(m)
}

func _MarmotService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarmotServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marmot.MarmotService/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarmotServiceServer).Start(ctx, req.(*StartReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarmotService_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarmotServiceServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marmot.MarmotService/Pause",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarmotServiceServer).Pause(ctx, req.(*PauseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarmotService_Resume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarmotServiceServer).Resume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marmot.MarmotService/Resume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarmotServiceServer).Resume(ctx, req.(*ResumeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarmotService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarmotServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marmot.MarmotService/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarmotServiceServer).Stop(ctx, req.(*StopReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarmotService_SearchLabor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LaborSearchReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MarmotServiceServer).SearchLabor(m, &marmotServiceSearchLaborServer{stream})
}

type MarmotService_SearchLaborServer interface {
	Send(*Labor) error
	grpc.ServerStream
}

type marmotServiceSearchLaborServer struct {
	grpc.ServerStream
}

func (x *marmotServiceSearchLaborServer) Send(m *Labor) error {
	return x.ServerStream.SendMsg(m)
}

func _MarmotService_FetchLabor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchLaborReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarmotServiceServer).FetchLabor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/marmot.MarmotService/FetchLabor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarmotServiceServer).FetchLabor(ctx, req.(*FetchLaborReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _MarmotService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "marmot.MarmotService",
	HandlerType: (*MarmotServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Submit",
			Handler:    _MarmotService_Submit_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _MarmotService_Start_Handler,
		},
		{
			MethodName: "Pause",
			Handler:    _MarmotService_Pause_Handler,
		},
		{
			MethodName: "Resume",
			Handler:    _MarmotService_Resume_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _MarmotService_Stop_Handler,
		},
		{
			MethodName: "FetchLabor",
			Handler:    _MarmotService_FetchLabor_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Monitor",
			Handler:       _MarmotService_Monitor_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SearchLabor",
			Handler:       _MarmotService_SearchLabor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("marmot.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1248 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x56, 0xcb, 0x92, 0xda, 0x46,
	0x17, 0x36, 0x08, 0x04, 0x3a, 0x82, 0x31, 0x73, 0x7c, 0x29, 0xfd, 0xd8, 0x7f, 0x79, 0x22, 0xbb,
	0x12, 0xc7, 0xb1, 0xc7, 0x2e, 0x9c, 0xca, 0x2e, 0x8b, 0xc9, 0xc0, 0xd8, 0xd8, 0x1e, 0xa0, 0x9a,
	0x19, 0x27, 0x95, 0x0d, 0x25, 0xa0, 0x67, 0x46, 0x31, 0x48, 0xb2, 0xba, 0xe5, 0x8a, 0x9f, 0x20,
	0xef, 0x90, 0xaa, 0xbc, 0x4a, 0xde, 0x20, 0x4f, 0x93, 0xaa, 0xac, 0x53, 0xa7, 0x5b, 0x17, 0x60,
	0xf0, 0x65, 0x93, 0x5d, 0xf7, 0xf7, 0x7d, 0x7d, 0xfa, 0x5c, 0x5b, 0x82, 0xc6, 0xd2, 0x8b, 0x97,
	0xa1, 0xdc, 0x8f, 0xe2, 0x50, 0x86, 0x68, 0xea, 0x9d, 0xfb, 0x1a, 0xaa, 0x63, 0xe9, 0x49, 0x8e,
	0xf7, 0xa0, 0x2a, 0x68, 0xe1, 0x94, 0xf6, 0x4a, 0xf7, 0x77, 0x3a, 0x3b, 0xfb, 0xa9, 0x5c, 0xb1,
	0x82, 0x69, 0x12, 0xbf, 0x02, 0x33, 0xe6, 0x9e, 0x08, 0x03, 0xa7, 0xac, 0x64, 0x57, 0x33, 0x19,
	0x53, 0xa8, 0x60, 0x29, 0xed, 0xbe, 0x06, 0xf3, 0xc4, 0x5f, 0xfa, 0xc1, 0x39, 0x3a, 0x50, 0x1b,
	0x4b, 0x2f, 0x96, 0x7c, 0xae, 0x4c, 0x1b, 0x2c, 0xdb, 0xe2, 0x75, 0xa8, 0xf6, 0x82, 0x39, 0x9f,
	0x2b, 0x5b, 0x06, 0xd3, 0x1b, 0xbc, 0x0d, 0xd6, 0x38, 0x99, 0x2e, 0x7d, 0x49, 0x27, 0x0c, 0xc5,
	0x14, 0x80, 0xdb, 0x00, 0x78, 0xee, 0x89, 0x0b, 0x3e, 0xef, 0x7a, 0xd2, 0x73, 0xff, 0x28, 0x43,
	0xf5, 0x95, 0x37, 0x0d, 0x63, 0x7c, 0x0c, 0xb5, 0x28, 0xf6, 0xdf, 0x65, 0x01, 0xd8, 0x9d, 0x1b,
	0x99, 0x67, 0x8a, 0xdf, 0x1f, 0x69, 0x92, 0x65, 0x2a, 0xdc, 0x81, 0xb2, 0xaf, 0x6f, 0xb6, 0x58,
	0xd9, 0x9f, 0xe3, 0x2d, 0xb0, 0x66, 0x0b, 0x9f, 0x07, 0x72, 0xe2, 0xeb, 0x6b, 0x2d, 0x56, 0xd7,
	0x40, 0x7f, 0x8e, 0x08, 0x95, 0xc0, 0x5b, 0x72, 0xa7, 0xa2, 0x70, 0xb5, 0x26, 0x6c, 0xce, 0xc5,
	0xcc, 0xa9, 0x6a, 0x8c, 0xd6, 0x84, 0x49, 0xef, 0x5c, 0x38, 0xe6, 0x9e, 0x41, 0x18, 0xad, 0xf1,
	0x4b, 0x30, 0xa5, 0xca, 0x84, 0x53, 0x53, 0x8e, 0xe5, 0x99, 0xd5, 0xf9, 0x61, 0x29, 0x8b, 0x77,
	0xb3, 0x02, 0xd4, 0x95, 0xac, 0xb9, 0x56, 0x80, 0x2c, 0xff, 0x2e, 0x54, 0xa5, 0x27, 0xde, 0x08,
	0xc7, 0xda, 0x33, 0xee, 0xdb, 0x9d, 0x46, 0x6e, 0xcb, 0x13, 0x6f, 0x98, 0xa6, 0xda, 0x16, 0xd4,
	0xd2, 0x68, 0xdd, 0x7f, 0x0c, 0xa8, 0x10, 0x85, 0xfb, 0x9b, 0xe9, 0xb9, 0xbe, 0x7a, 0xf2, 0xd3,
	0xd9, 0xc9, 0x12, 0x60, 0x6c, 0x49, 0x40, 0x65, 0x25, 0x01, 0x45, 0xb0, 0xd5, 0xcf, 0x0b, 0xd6,
	0xfc, 0x48, 0xb0, 0x8f, 0x00, 0x65, 0xb8, 0xe0, 0xb1, 0x27, 0xf9, 0x7c, 0x72, 0xe6, 0xf9, 0x8b,
	0x24, 0xe6, 0x42, 0x65, 0xd1, 0x60, 0xbb, 0x39, 0x73, 0x94, 0x12, 0xb8, 0x07, 0xf6, 0x2c, 0x0c,
	0x66, 0x49, 0x1c, 0xf3, 0x60, 0xf6, 0x5e, 0xa5, 0xd1, 0x60, 0xab, 0x10, 0xee, 0xc3, 0xb5, 0x59,
	0x18, 0xc8, 0xc9, 0xec, 0x82, 0xcf, 0xde, 0x4c, 0xfc, 0x40, 0xf2, 0xf8, 0x9d, 0xb7, 0x70, 0x2c,
	0x6d, 0x91, 0xa8, 0x43, 0x62, 0xfa, 0x29, 0x81, 0x77, 0xa1, 0x19, 0x79, 0x42, 0x14, 0x77, 0xc3,
	0x5e, 0xe9, 0x7e, 0x9d, 0x35, 0x08, 0xcc, 0xaf, 0x7d, 0x00, 0x10, 0xc5, 0x5c, 0xdb, 0x14, 0x8e,
	0xad, 0xea, 0x62, 0x67, 0xf1, 0xbc, 0x08, 0xa7, 0xcc, 0x8a, 0x62, 0xae, 0xec, 0x0a, 0x7c, 0xa8,
	0x5c, 0x94, 0x99, 0xb8, 0x71, 0x59, 0x0c, 0xb9, 0x17, 0x02, 0xf7, 0xc1, 0x12, 0xfc, 0x6d, 0xc2,
	0x83, 0x19, 0x17, 0x4e, 0x53, 0x69, 0x5b, 0x79, 0xa2, 0x52, 0x82, 0x15, 0x92, 0xd5, 0xc2, 0xff,
	0x5d, 0x82, 0x7a, 0x26, 0xc1, 0xce, 0x66, 0xf1, 0x9d, 0x4d, 0x2b, 0x9f, 0x6e, 0x80, 0x9b, 0x60,
	0x4a, 0x2f, 0x3e, 0xe7, 0x32, 0x6d, 0x81, 0x74, 0xf7, 0xdf, 0x37, 0xc1, 0x1d, 0xa8, 0xfc, 0x12,
	0x4e, 0x29, 0xf5, 0x97, 0x72, 0xa5, 0x88, 0xd5, 0xa8, 0x7f, 0x33, 0xc0, 0x78, 0x11, 0x4e, 0xf1,
	0xd1, 0x66, 0xc0, 0xd7, 0x56, 0x8e, 0x7d, 0x56, 0xac, 0xd1, 0x22, 0x39, 0xf7, 0x83, 0x2c, 0x56,
	0xbd, 0xdb, 0x1a, 0xab, 0x03, 0x35, 0xe9, 0x2f, 0x79, 0x98, 0x48, 0x15, 0xac, 0xc1, 0xb2, 0xed,
	0x4a, 0x16, 0xcc, 0xcf, 0xcb, 0x42, 0xed, 0x23, 0x59, 0x40, 0xa8, 0x78, 0xf1, 0xb9, 0x50, 0x4d,
	0x6d, 0x31, 0xb5, 0x26, 0x37, 0x87, 0x89, 0x8c, 0x12, 0xa9, 0x1a, 0xd8, 0x62, 0xe9, 0x8e, 0x5c,
	0x8a, 0xb9, 0x8c, 0xfd, 0xb4, 0x5f, 0x0d, 0x96, 0x6d, 0xf1, 0x0e, 0xd8, 0xb4, 0x7c, 0x3f, 0x99,
	0xf3, 0x85, 0xf7, 0xde, 0xb1, 0x15, 0x0b, 0x0a, 0xea, 0x12, 0xd2, 0x7e, 0x96, 0xe7, 0x92, 0xde,
	0x43, 0xba, 0x65, 0x72, 0xe1, 0x89, 0x8b, 0xf4, 0x82, 0x3a, 0x01, 0xf4, 0xfa, 0x92, 0xa1, 0x50,
	0x5d, 0xa6, 0x69, 0x50, 0x34, 0x68, 0x88, 0x04, 0xee, 0xeb, 0xec, 0x11, 0x67, 0xfc, 0x2d, 0x45,
	0xb8, 0xa0, 0x47, 0x38, 0x2d, 0x46, 0x73, 0xed, 0x65, 0x66, 0x9a, 0xc3, 0x7b, 0xd0, 0x54, 0xdf,
	0x85, 0x61, 0xa0, 0x0f, 0xaa, 0x7a, 0xd4, 0xd9, 0x3a, 0xe8, 0xde, 0x06, 0xc8, 0xec, 0x8a, 0x28,
	0x2d, 0x5c, 0x29, 0x2b, 0x1c, 0xb1, 0xc7, 0x61, 0xe0, 0xcb, 0x30, 0xa6, 0x6b, 0x37, 0xd9, 0x0e,
	0xd8, 0x39, 0x2b, 0xa2, 0xc2, 0xab, 0xf2, 0x87, 0xbd, 0x72, 0xdb, 0x50, 0x57, 0x0e, 0x6c, 0xb3,
	0x67, 0x83, 0x95, 0x72, 0x22, 0x22, 0xe1, 0xc8, 0x4b, 0x04, 0xff, 0x80, 0x30, 0xe5, 0x44, 0xe4,
	0xde, 0x02, 0x8b, 0x71, 0x91, 0x2c, 0xb7, 0x2a, 0x1b, 0x00, 0x19, 0x29, 0x22, 0xf7, 0x7f, 0xf4,
	0xe5, 0x0c, 0xa3, 0x6d, 0x42, 0x20, 0xbf, 0x88, 0x12, 0x91, 0xfb, 0x57, 0x09, 0x6c, 0xe5, 0xf4,
	0x91, 0xbf, 0x90, 0x3c, 0xa6, 0xc6, 0x53, 0x4d, 0x23, 0x9c, 0xd2, 0x9e, 0xb1, 0xe5, 0x53, 0x9e,
	0xb2, 0x54, 0x44, 0x7a, 0xc7, 0x27, 0x51, 0xcc, 0xcf, 0xfc, 0x5f, 0xd3, 0xfe, 0x07, 0x82, 0x46,
	0x0a, 0xc9, 0x05, 0x22, 0x39, 0x23, 0x81, 0x51, 0x08, 0xc6, 0x0a, 0xc9, 0x3f, 0x77, 0x95, 0x95,
	0xcf, 0xdd, 0x17, 0xd0, 0x10, 0xaa, 0x42, 0x93, 0x29, 0xa7, 0x11, 0xd2, 0x53, 0x61, 0x6b, 0xec,
	0x07, 0x82, 0xf0, 0xff, 0x00, 0xa9, 0x84, 0x07, 0x73, 0x35, 0x1d, 0x06, 0xb3, 0x34, 0xd2, 0x0b,
	0xe6, 0xee, 0xf7, 0xb0, 0xa3, 0xc2, 0x19, 0x73, 0x2f, 0x9e, 0x5d, 0x50, 0xf4, 0xdf, 0x80, 0x79,
	0xa6, 0x62, 0xdb, 0x1c, 0xe7, 0x95, 0xb0, 0x59, 0x2a, 0x71, 0x9f, 0x42, 0xf3, 0x88, 0xcb, 0xd9,
	0x85, 0xae, 0xe3, 0xe5, 0xdc, 0x91, 0xd7, 0x67, 0xc9, 0x62, 0x91, 0x36, 0x98, 0x5a, 0x3f, 0xf8,
	0xb3, 0x04, 0xa6, 0x4e, 0x0f, 0xda, 0x50, 0x3b, 0x1d, 0xbc, 0x1c, 0x0c, 0x7f, 0x1c, 0xb4, 0xae,
	0xe0, 0x55, 0xb0, 0x07, 0xc3, 0x93, 0xc9, 0xf8, 0xe4, 0x80, 0x9d, 0xf4, 0xba, 0xad, 0x12, 0xde,
	0x80, 0xdd, 0x83, 0xee, 0x71, 0x7f, 0x30, 0x59, 0x85, 0xcb, 0x74, 0x88, 0x9d, 0x0e, 0x06, 0xfd,
	0xc1, 0xb3, 0x96, 0x41, 0x9b, 0xd1, 0xc1, 0xe9, 0x98, 0x36, 0x15, 0x04, 0x30, 0x69, 0xd3, 0xeb,
	0xb6, 0xaa, 0xd8, 0x82, 0x86, 0x3e, 0x9c, 0x22, 0x26, 0xee, 0x42, 0xf3, 0x90, 0xf5, 0xc7, 0xfd,
	0x71, 0x06, 0xd5, 0xb0, 0x09, 0xd6, 0xe1, 0xf0, 0x78, 0xf4, 0xaa, 0x47, 0x96, 0xeb, 0x74, 0xfe,
	0xe8, 0xa0, 0xff, 0xaa, 0xd7, 0x6d, 0x59, 0xd8, 0x80, 0xfa, 0xf8, 0x64, 0x38, 0x1a, 0x91, 0x65,
	0xa0, 0x6b, 0xd4, 0xae, 0xd7, 0x6d, 0xd9, 0x0f, 0x7e, 0x86, 0x5a, 0xfa, 0x0b, 0x86, 0x3b, 0x00,
	0x83, 0xe1, 0x84, 0x0e, 0x9d, 0xb2, 0x5e, 0xeb, 0x0a, 0xb9, 0x3c, 0x62, 0xbd, 0xc9, 0xe1, 0xf3,
	0xde, 0xe1, 0xcb, 0x1c, 0x2e, 0xe1, 0x4d, 0xc0, 0xc3, 0xe1, 0xe0, 0x64, 0x03, 0x2f, 0x93, 0x93,
	0xc7, 0x07, 0x3f, 0x65, 0xc0, 0xb8, 0x65, 0x74, 0x7e, 0x37, 0xa0, 0x79, 0xac, 0x12, 0x3e, 0xe6,
	0xf1, 0x3b, 0x7f, 0xc6, 0xf1, 0x31, 0x98, 0x7a, 0x0c, 0x71, 0x37, 0x6f, 0xae, 0x6c, 0xdc, 0xdb,
	0xb8, 0x09, 0x89, 0x08, 0xbf, 0x85, 0x5a, 0x3a, 0x7b, 0x98, 0xd3, 0xc5, 0xa8, 0xb6, 0xaf, 0x5d,
	0xc2, 0x44, 0xf4, 0xa4, 0x84, 0x0f, 0xd5, 0xcf, 0x69, 0x2c, 0xb1, 0xb5, 0xd2, 0xc2, 0x6a, 0x18,
	0xdb, 0xbb, 0x1b, 0x88, 0x88, 0x48, 0xad, 0xc6, 0xac, 0x50, 0x67, 0x13, 0x59, 0xa8, 0xf3, 0x39,
	0xa4, 0x10, 0xf4, 0xa8, 0x15, 0x21, 0xe4, 0x73, 0x59, 0x84, 0x50, 0x4c, 0x23, 0x7e, 0x0d, 0x15,
	0x1a, 0x39, 0xbc, 0x5a, 0xdc, 0xac, 0x66, 0xb3, 0xdd, 0x5a, 0x07, 0x44, 0x84, 0xdf, 0x81, 0xad,
	0x9b, 0x57, 0xff, 0x9b, 0xde, 0x5c, 0x6b, 0xd7, 0xbc, 0xad, 0xdb, 0xeb, 0x4f, 0xce, 0x93, 0x12,
	0x76, 0x00, 0x8a, 0xd6, 0xc5, 0xfc, 0x0f, 0x76, 0xad, 0x9d, 0x37, 0x4e, 0x4d, 0x4d, 0xf5, 0x3f,
	0xff, 0xf4, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd0, 0x17, 0xe9, 0xf8, 0xdf, 0x0b, 0x00, 0x00,
}
